				Working Prototype of the IGP - ISIS
				------------------------------------

OSPF favoured more now in the industry when ISIS is being shown more interest and preferred over ospf
more by network admins

[High level]
Four Phases of working of IGP Protocols

	1. Adjacency Management (The neighbours are know to each devices)
		* Sending and Receiving hello packets periodically
		* Updating neighbours state machine
	2. Building Link State Database (Each device internally creates a view of topology -- Graph)
		* Building Link State Packets
		* Flooding Link State Packets
		* Build a graph - {a view of the network topology}
	3. Running SPF algorithms (Dijkstra) on LSDB
		* Process the LSDB through the algorithm
		* Compute the results and store
		* Algorithm challenged
	4. L3 Route Calculations
		* Use Results of 3 to compute final L3 routes and update routing
		* Table
		* Algorithms challenged

L3 Routing Table Architecture
------------------------------

Objectives to be implemented
-------------------------------
	> Reaching of Traffic to its intended Destination via Cooperation of L3 devices
	> Always use the shortest Paths
	> No loops
	> ECMP [Equal Cost Multiple Path]
	> Nodes should recompute RT if topology of the network changes


Constructed Problem Statement
--------------------------------
	> For a given network Graph,  Compute the routing table of each node present in the graph
	> Input Graph has nodes which are L3 routers and the edges represent the wires connecting them
	> All the edges are P2P links and there is a cost attached to it
	> Nodes have Name, and LoopBack address
Output
------
  	> Routing Table
  	> Each node should compute the routing table
  	> Each node must know how to reach (a nexthop) a given remote subnet in the graph (loopback addr
  	  of other L3 devices)

Proposed L3 route Entry Format:
--------------------------------

Routing Table of node S for example
OIF --> represents the ethernet interface
Nexthop ip address {gateway} --> represents the IP address present on the other side of the interface

The key is the destination IP address which is used as a unique ID for a node
No 2 nodes in the routing Table can have same destination address

{Destination} | {Gateway-ip} | {OIF} | {cost} | {nexthop-node} |
------------------------------------------------------------------
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
|             |              |       |        |                |
----------------------------------------------------------------

ECMP [Equal Cost Multiple Path]
--------------------------------
When there exists path where travelling to the destination deals with the same amount of weight
then the routing table works a bit differently

In the field of Oif ---> there will be present more than 2 interfaces like
	> eth0/1 and eth0/2

So that the data from the source to the destination can reach the node
equally through each of them to the destination

Phase 1 --> Building the input graph
    --------------------------------------
	> Exchanging packets between the nodes
	> Building database regarding the neighbours
		> Every routing device should know its neighbours
	> Flooding the neighbour's database to store the information about the
		neighbours of the nodes
	> Building the cumulative neighbours database i:e the network graph

Exchange of packets and Building Database
------------------------------------------
	> Edge Case : The packets should be exchanges only between directly connected nodes

	Structure of Packets
	--------------------

	{"R1", 10.0.0.1/24, eth0, 122.1.1.2,...etc}
	{routername, source, interface, own_loopback_addr.. etc}

Neighbour's Database
---------------------

Peer Interface --> interface through which Router R2 receives the data
Local Interface --> interface of R2 for sending data
Local IP --> IP of R2
Peer IP ---> IP of R1
Neighbour Loopback Address --> LoopBack address of R1

Example DB for R2
------------------
Neigbhour Name | Peer interface | Local Interface | Peer IP    | Local IP   | Neighbour Loopback Address |
	R1		eth0		eth1	    10.1.1.1/24  10.1.1.2/24   122.1.1.1

Flooding of Database
---------------------

The contents of the database for R2 or any other router is to be conveyed to all the other L3 routers
database by some packet mechanism to the routers called link state packets
	> LSP is to be used by all the routers to copy their neighbour-ship database
	> Then convey these packets to other routers

Objectives to be implemented after receiving the packets
	> Store it into the local memory
	> Forward the packet to the other routers

Collection of all LSP of all routing Device is called LSPDB --> NETWORK GRAPH
[link state packet database]
Every node should build up the same LSPDB, Every node has the same view of the physical network
topology in the form of a graph data structure

Phase 2 ---> SPF Algorithm on Input Graph [Dijkstra]
-----------------------------------------

Evaluating the neighbours ---> Dequeing the least code node ----> Recording Result ---> Back to step1

Pseudo Code
------------

1) Initialize distances of all vertices as infinite.

2) Create an empty priority_queue pq.  Every item
   of pq is a pair (weight, vertex). Weight (or
   distance) is used  as first item  of pair
   as first item is by default used to compare
   two pairs

3) Insert source vertex into pq and make its
   distance as 0.

4) While either pq doesn't become empty
    a) Extract minimum distance vertex from pq.
       Let the extracted vertex be u.
    b) Loop through all adjacent of u and do
       following for every vertex v.

           // If there is a shorter path to v
           // through u.
           If dist[v] > dist[u] + weight(u, v)

               (i) Update distance of v, i.e., do
                     dist[v] = dist[u] + weight(u, v)
               (ii) Insert v into the pq (Even if v is
                    already there)

5) Print distance array dist[] to print all shortest
   paths.

Python implementation
----------------------

from queue import PriorityQueue # essentially a binary heap

def dijkstra(G, start, goal):
    """ Uniform-cost search / dijkstra """
    visited = set()
    cost = {start: 0}
    parent = {start: None}
    todo = PriorityQueue()

    todo.put((0, start))
    while todo:
        while not todo.empty():
            _, vertex = todo.get() # finds lowest cost vertex
            # loop until we get a fresh vertex
            if vertex not in visited: break
        else: # if todo ran out
            break # quit main loop
        visited.add(vertex)
        if vertex == goal:
            break
        for neighbor, distance in G[vertex]:
            if neighbor in visited: continue # skip these to save time
            old_cost = cost.get(neighbor, float('inf')) # default to infinity
            new_cost = cost[vertex] + distance
            if new_cost < old_cost:
                todo.put((new_cost, neighbor))
                cost[neighbor] = new_cost
                parent[neighbor] = vertex

    return parent

def make_path(parent, goal):
    if goal not in parent:
        return None
    v = goal
    path = []
    while v is not None: # root has null parent
        path.append(v)
        v = parent[v]
    return path[::-1]


## Example

G = { # random example graph
 'A': {('C', 76)},
 'B': {('C', 20), ('J', 78)},
 'C': {('C', 62), ('F', 99), ('G', 72), ('H', 40)},
 'D': {('A',  8), ('G', 71), ('I', 61)},
 'E': {('C', 16), ('E', 54), ('I',  3)},
 'F': {('J', 66)},
 'G': {('B', 92), ('E', 48), ('G', 31)},
 'H': {('G', 36)},
 'I': {('J', 88), ('K', 16)},
 'J': {('H',  4), ('K', 46)},
 'K': {('I', 40)}
}

parent = dijkstra(G, 'A', 'K')
print(make_path(parent, 'K'))

C implementation
------------------

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// A structure to represent a
// node in adjacency list
struct AdjListNode
{
    int dest;
    int weight;
    struct AdjListNode* next;
};

// A structure to represent
// an adjacency list
struct AdjList
{

   // Pointer to head node of list
   struct AdjListNode *head;
};

// A structure to represent a graph.
// A graph is an array of adjacency lists.
// Size of array will be V (number of
// vertices in graph)
struct Graph
{
    int V;
    struct AdjList* array;
};

// A utility function to create
// a new adjacency list node
struct AdjListNode* newAdjListNode(
                   int dest, int weight)
{
    struct AdjListNode* newNode =
            (struct AdjListNode*)
      malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// A utility function that creates
// a graph of V vertices
struct Graph* createGraph(int V)
{
    struct Graph* graph = (struct Graph*)
            malloc(sizeof(struct Graph));
    graph->V = V;

    // Create an array of adjacency lists.
    // Size of array will be V
    graph->array = (struct AdjList*)
       malloc(V * sizeof(struct AdjList));

    // Initialize each adjacency list
    // as empty by making head as NULL
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;

    return graph;
}

// Adds an edge to an undirected graph
void addEdge(struct Graph* graph, int src,
                   int dest, int weight)
{
    // Add an edge from src to dest.
    // A new node is added to the adjacency
    // list of src.  The node is
    // added at the beginning
    struct AdjListNode* newNode =
            newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    // Since graph is undirected,
    // add an edge from dest to src also
    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// Structure to represent a min heap node
struct MinHeapNode
{
    int  v;
    int dist;
};

// Structure to represent a min heap
struct MinHeap
{

    // Number of heap nodes present currently
    int size;

    // Capacity of min heap
    int capacity;

    // This is needed for decreaseKey()
    int *pos;
    struct MinHeapNode **array;
};

// A utility function to create a
// new Min Heap Node
struct MinHeapNode* newMinHeapNode(int v,
                                 int dist)
{
    struct MinHeapNode* minHeapNode =
           (struct MinHeapNode*)
      malloc(sizeof(struct MinHeapNode));
    minHeapNode->v = v;
    minHeapNode->dist = dist;
    return minHeapNode;
}

// A utility function to create a Min Heap
struct MinHeap* createMinHeap(int capacity)
{
    struct MinHeap* minHeap =
         (struct MinHeap*)
      malloc(sizeof(struct MinHeap));
    minHeap->pos = (int *)malloc(
            capacity * sizeof(int));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array =
         (struct MinHeapNode**)
                 malloc(capacity *
       sizeof(struct MinHeapNode*));
    return minHeap;
}

// A utility function to swap two
// nodes of min heap.
// Needed for min heapify
void swapMinHeapNode(struct MinHeapNode** a,
                     struct MinHeapNode** b)
{
    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

// A standard function to
// heapify at given idx
// This function also updates
// position of nodes when they are swapped.
// Position is needed for decreaseKey()
void minHeapify(struct MinHeap* minHeap,
                                  int idx)
{
    int smallest, left, right;
    smallest = idx;
    left = 2 * idx + 1;
    right = 2 * idx + 2;

    if (left < minHeap->size &&
        minHeap->array[left]->dist <
         minHeap->array[smallest]->dist )
      smallest = left;

    if (right < minHeap->size &&
        minHeap->array[right]->dist <
         minHeap->array[smallest]->dist )
      smallest = right;

    if (smallest != idx)
    {
        // The nodes to be swapped in min heap
        MinHeapNode *smallestNode =
             minHeap->array[smallest];
        MinHeapNode *idxNode =
                 minHeap->array[idx];

        // Swap positions
        minHeap->pos[smallestNode->v] = idx;
        minHeap->pos[idxNode->v] = smallest;

        // Swap nodes
        swapMinHeapNode(&minHeap->array[smallest],
                         &minHeap->array[idx]);

        minHeapify(minHeap, smallest);
    }
}

// A utility function to check if
// the given minHeap is empty or not
int isEmpty(struct MinHeap* minHeap)
{
    return minHeap->size == 0;
}

// Standard function to extract
// minimum node from heap
struct MinHeapNode* extractMin(struct MinHeap*
                                   minHeap)
{
    if (isEmpty(minHeap))
        return NULL;

    // Store the root node
    struct MinHeapNode* root =
                   minHeap->array[0];

    // Replace root node with last node
    struct MinHeapNode* lastNode =
         minHeap->array[minHeap->size - 1];
    minHeap->array[0] = lastNode;

    // Update position of last node
    minHeap->pos[root->v] = minHeap->size-1;
    minHeap->pos[lastNode->v] = 0;

    // Reduce heap size and heapify root
    --minHeap->size;
    minHeapify(minHeap, 0);

    return root;
}

// Function to decreasekey dist value
// of a given vertex v. This function
// uses pos[] of min heap to get the
// current index of node in min heap
void decreaseKey(struct MinHeap* minHeap,
                         int v, int dist)
{
    // Get the index of v in  heap array
    int i = minHeap->pos[v];

    // Get the node and update its dist value
    minHeap->array[i]->dist = dist;

    // Travel up while the complete
    // tree is not heapified.
    // This is a O(Logn) loop
    while (i && minHeap->array[i]->dist <
           minHeap->array[(i - 1) / 2]->dist)
    {
        // Swap this node with its parent
        minHeap->pos[minHeap->array[i]->v] =
                                      (i-1)/2;
        minHeap->pos[minHeap->array[
                             (i-1)/2]->v] = i;
        swapMinHeapNode(&minHeap->array[i],
                 &minHeap->array[(i - 1) / 2]);

        // move to parent index
        i = (i - 1) / 2;
    }
}

// A utility function to check if a given vertex
// 'v' is in min heap or not
bool isInMinHeap(struct MinHeap *minHeap, int v)
{
   if (minHeap->pos[v] < minHeap->size)
     return true;
   return false;
}

// A utility function used to print the solution
void printArr(int dist[], int n)
{
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}

// The main function that calculates
// distances of shortest paths from src to all
// vertices. It is a O(ELogV) function
void dijkstra(struct Graph* graph, int src)
{

    // Get the number of vertices in graph
    int V = graph->V;

    // dist values used to pick
    // minimum weight edge in cut
    int dist[V];

    // minHeap represents set E
    struct MinHeap* minHeap = createMinHeap(V);

    // Initialize min heap with all
    // vertices. dist value of all vertices
    for (int v = 0; v < V; ++v)
    {
        dist[v] = INT_MAX;
        minHeap->array[v] = newMinHeapNode(v,
                                      dist[v]);
        minHeap->pos[v] = v;
    }

    // Make dist value of src vertex
    // as 0 so that it is extracted first
    minHeap->array[src] =
          newMinHeapNode(src, dist[src]);
    minHeap->pos[src]   = src;
    dist[src] = 0;
    decreaseKey(minHeap, src, dist[src]);

    // Initially size of min heap is equal to V
    minHeap->size = V;

    // In the following loop,
    // min heap contains all nodes
    // whose shortest distance
    // is not yet finalized.
    while (!isEmpty(minHeap))
    {
        // Extract the vertex with
        // minimum distance value
        struct MinHeapNode* minHeapNode =
                     extractMin(minHeap);

        // Store the extracted vertex number
        int u = minHeapNode->v;

        // Traverse through all adjacent
        // vertices of u (the extracted
        // vertex) and update
        // their distance values
        struct AdjListNode* pCrawl =
                     graph->array[u].head;
        while (pCrawl != NULL)
        {
            int v = pCrawl->dest;

            // If shortest distance to v is
            // not finalized yet, and distance to v
            // through u is less than its
            // previously calculated distance
            if (isInMinHeap(minHeap, v) &&
                      dist[u] != INT_MAX &&
              pCrawl->weight + dist[u] < dist[v])
            {
                dist[v] = dist[u] + pCrawl->weight;

                // update distance
                // value in min heap also
                decreaseKey(minHeap, v, dist[v]);
            }
            pCrawl = pCrawl->next;
        }
    }

    // print the calculated shortest distances
    printArr(dist, V);
}


// Driver program to test above functions
int main()
{
    // create the graph given in above figure
    int V = 9;
    struct Graph* graph = createGraph(V);
    addEdge(graph, 0, 1, 4);
    addEdge(graph, 0, 7, 8);
    addEdge(graph, 1, 2, 8);
    addEdge(graph, 1, 7, 11);
    addEdge(graph, 2, 3, 7);
    addEdge(graph, 2, 8, 2);
    addEdge(graph, 2, 5, 4);
    addEdge(graph, 3, 4, 9);
    addEdge(graph, 3, 5, 14);
    addEdge(graph, 4, 5, 10);
    addEdge(graph, 5, 6, 2);
    addEdge(graph, 6, 7, 1);
    addEdge(graph, 6, 8, 6);
    addEdge(graph, 7, 8, 7);

    dijkstra(graph, 0);

    return 0;
}

Time Complexity: The time complexity of the above code/algorithm looks O(V^2) as there are two nested while loops. If we take a closer look, we can observe that the statements in the inner loop are executed O(V+E) times (similar to BFS). The inner loop has decreaseKey() operation which takes O(LogV) time. So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)
Note that the above code uses Binary Heap for Priority Queue implementation. Time complexity can be reduced to O(E + VLogV) using Fibonacci Heap. The reason is, that Fibonacci Heap takes O(1) time for decrease-key operation while Binary Heap takes O(Logn) time.

Rules for SPF
-------------
		cost=m
Node X --------------------------------------- Node Y
cost = x                                     cost = y
nh1, nh2                                     nh1, nh3

Cases for new nodes being explored
-----------------------------------
	> if node y is explored from predecessor node X with a better metric
		x + m < y
			--> remove next hops of y
			--> copy nexthops of x into y
			--> remove from PQ if present and add it back to PQ
	> if node y is explored from predecessor node X with a same metric
		x + m + y (ECMP Case)
			--> keep existing nexthops of y
			--> copy nexthops of x into y
			--> remove duplicates in nexthops of y if present any
	> if node Y is explored from predecessor node X with higher metric
		x + m > y
			--> No action
	> Algorithm should stop when its empty

Phase 3 --> Routing Table Calculation
-------------------------------------

Replace the destination nodes names in the Routing Table with their loopback address
and we can obtain the complete Routing Table Calculation

Proposed Ecosystem for Developing the Protocol Stack
----------------------------------------------------

		Application Layer [OSPF,BGP, ISIS, MPLS, etc]
		Network Layer [IP, IPv6]
		Data Link Layer [ARP]
		Physical Layer

		Required Ecosystem
		--------------------
		Supportive Base application interface managers, Build System
		UI : CLIS, GUIS
		System Calls -> fork(), Sockets, IPC
		Underlying tcp/ip stack layer support
		Testing and automation infrastructure
		Data structures like linked lists and trees
		System Supportive libraries ilke Schedulers, Memory Managers , Timers and Locking etc
		NIC Drivers for Pkt Transmission

		The TCP/IP stack sdk toolkit will partially(as it doesnt supports NICs) it  simulate these.

TARGETS
--------

Feature 1     --> Adding cli integration for ISIS protocol in the tcp_ip stack sdk toolkit to
		  start and end the initiation for ISIS protocol

	config node <node-name> [yes] protocol isis
	config node <node-name> [no] protocol isis


	Adding entry of the layer 5 protocol in the tcp ip stack sdk toolkit

Makefile
----------
Objects
	Layer5/isis/isis_cli.o

Layer5/isis/isis_cli.o:Layer5isis_cli.c
${CC} ${CFLAGS} -c -I . Layer5/isis/isis_cli.c -o Layer5/isis/isis_cli.o

clean:
	rm -f Layer5/isis/*.o

Backend Handler implementation
--------------------------------
    Objectives
        > Extract the command codes
        > Parse the data from the buffer to get the data
        > Parse the command code in and use it for init and de-init
                > implement init
                > implement de-init


        init implement
                > fetch the current isis info for the current node
                > allocate new node as enabled
                > if its not null then update the information in then network properties graph by swapping the new val of the new node
                    to the old node

        dinit implement
                > fetch the current isis info for the current node
                > then free the memory for the allocated node

Feature 2
----------

Protocol Configuration Holders
--------------------------------

Needed for holding Configuration files for the node's protocol's at the device and
interface level

    Examples: [device-levels]
        > do not generate lsp packets
        > advertise some information in lsp packets
        >  if protocol is disabled then it disabled on all the interfaces

    Examples: [interface-levels]
        > Impacting protocol behaviour per interface
        > Stop sending lsp packets out of eth0
        > Start generating lsp packets out of eth0 at some time interval_sec
        > Enable or disable protocol on eth4

    Proposed
    ---------

    Add protocol specific node and per-interface level data Configuration holders

        > Add the data structures to isis_rtr.h and isis_intf.h
            for device and interface levels

        > After adding these add isis_rtr.h's data structure
          in the node_nw_prop data structure
          because it holds the data at the device levels
          and now it will be able to hold protocol based device configs
          and same for interfaces as well at intf_nw_props {net.h}



Feature 3 -- > show node <node-name> proto isis

Responible for fetching device level configs of the isis protocol
    > will show isis protocol is enabled or disabled

    > Add the main tree in the isis_cli
    > Register as a show command in the isis_cli
    > Add the command codes for checking if isis_show_node_protocol_state is enabled or disabled
    > Return the status

    Test
    ----
        enable --> conf node R0 proto isis
        check status --> show node R0 proto isis
        disable --> conf node R0 no proto isis
        check status --> show node R0 proto isis


Feature 4 --> conf node <node-name> [no] proto isis interface all

            must enable/disable protocol (alloc/free) isis_intf_info on all interfaces of device

            conf node <node-name> [no] proto isis interface <intf-name>

            same thing on a particular interface as well

    Important --> Disabling the protocol on a device must disable protocol on all interfaces also
                  Enabling the protocol on a device must not enable protocol at interface level, user should
                  do it manually through above new clis



Feature 5 --> Packet Exchange Architecture

    Packet Type 1 [Hello Packet Exchange]

    Naming scheme --> R1-eth0 ---> Router-interface of the router

    Proposed contents in the packets
    1. Rtr ID [loopback interface of the router ]
    2. HostName [user friendly name of the router ]
    3. IP address [Ip address through which the packet was sent out]
    4. IfIndex [Interface ID of the device to identify] --> has to be unique
    5. Hold-time
    6. Metric Value

    Example
    1. 122.1.1.1
    2. R1
    3. 10.1.1.1
    4. 50
    5. 5 (holding time)
    6. 10 (cost) can be only configured by the admins

    These packets should be specific from the interface they are coming out.

    Adjaency matrix will be used for these packets as there are neighbours involved.

    High level Implementation

    typedef struct isis_adjancency_t {

        // back pointer to the interface to find out which interface its pointing
        interface_t *intf;
        // neighboring loopback address
        ip_add_t nbr_rtr_id;
        // neighboring device name
        unsigned char nbr_name[NODE_NAME_SIZE];
        // neighboring interface ip
        ip_add_t nbr_intf_ip;
        // holding time in sec by the neighbour
        uint32_t hold_time;
        // nbr link cost value
        uint32_t cost;
        // adjacency state
        isis_adj_state_t adj_state;
        // uptime --> how much time has elapsed since the adjacency state has been first
        // transitioned to the up state
        time_t uptime;
        // delete timer
        timer_event_handle *delete_timer;
        // expiry timer
        timer_event_handle *expiry_timer;
    } isis_adjacency_t;


    Adjacency state

    States --> Down , Init, Up

    for first packet received set the state to down
    for second packet received set the state to init from down
    for third packet received set the state to up from init
    if there is some holding time on the interface
        > if state is up --> set it to down ---> delete it after some time if no hello packet received
        > if state is down --> no packets are coming for some time --> delete it

    State transition engine --> Adjacency State Machine

    typedef enum isis_adj_state {
        ISIS_ADJ_STATE_UNKNOW,
        ISIS_ADJ_STATE_DOWN,
        ISIS_ADJ_STATE_UP,

    }isis_adj_state_t;


    TIMER_SUB LIBRARY --> helping in scheduling the events to be performed in future after some time after some definite period time

    Timers Proposed

    1. Delete timer
        > delete the adjancency permanently after 5 sec

    2. Expiry timer
        > holding time
        > Changing the adjacency state from the up/init state to down state
        > start the delete timer


    Targets to be implemented
        > hello packet format
        > manufacturing architecture of hello packets from node and interface data
        > sending out periodic packet out of protocol enabled interfaces
        > stopping hello packets when protocol is disabled on the interfaces
        > Receiving the hello packets on the receipents node
        > Processing hello packets
        > Creating adjacency objects from processing information from hello packets
        > Enhanced version of show command to display the adjacency object attributes
        > Timer management involved in the adjacency object
        > Updating the hello packet configs if any changes are made in the generic config by the admin
        > Adjacency State machine implementation

    The isis protocol packets should be formatted as TLV
    TLV -> Type length value

    TLV is a mechanism of packaging the data in a type length value order

    Benifits ::
    1. They are flexible, easy to add and remove the data
    2. No ties are required to any pre-defined software
    3. The recipent node can ignore any data which is not recognized by it
    4. The recipent node can fetch the data which is recognized by it

    TLV example

    Type --> 1    \\ range 0-255 [type is used to identify the tlv it is unique]
    Length --> 8  \\ length of the value
    Value --> Purbayan \\

    There can be several tlv that can be defined
    example tlv of type1, type2, type3

    https://www.cisco.com/c/en/us/support/docs/ip/integrated-intermediate-system-to-intermediate-system-is-is/5739-tlvs-5739.html


    TLV type and length are together called TLV overhead
    TLV from code point of view gives two information
        > data type of value i:e string, integer, float,
        > length of the 1 unit of data

    The TLV can contain multiple values
    The contigous memory that holds the tlv is called the TLV buffer

    Example

                    Type 1
                    length 64
                    "isis"
                    "proto"
                    type 2
                    length 128
                    "is"
                    "fun"
                    type 3
                    length 24
                    "to"
                    "use"
                    "really"

            This is the TLV buffer

            Some macros to iterate through this buffer

    # define TLV_OVERHEAD_SIZE 2 // arbitary value can be changed

    # define ITERATE_TLV_BEGIN(start_ptr, type, length, tlv_ptr, tlv_size) {
        unsigned int _len = 0;
        unsigned char _tlv_value_size = 0;
        for (tlv_ptr = (unsigned char *) start_ptr + TLV_OVERHEAD_SIZE; _len < tlv_size; _len += tlv_value_size + TLV_OVERHEAD_SIZE, tlv_ptr = (tlv_ptr + TLV_OVERHEAD_SIZE + length )) {
            type = *(tlv_ptr + TLV_OVERHEAD_SIZE);
            _tlv_value_size = (unsigned char)(*(tlv_ptr - TLV_OVERHEAD_SIZE + sizeof(unsigned char)));
    # define ITERATE_TLV_END(start_ptr, type, length, tlv_ptr, buffer_size)
        }
    }

    This macros can be used to traverse the tlv very easily
    char *tlv_buffer = ptr to the tlv buffer
    uint32_t total_size = 222


    uint_t type, uint8_t len;
    char *val;
    ITERATE_TLV_BEGIN(start_ptr, type, length, tlv_ptr, tlv_size) {

        switch(type) {

            case first_tlv_code:
                process 'val';
                break;
            case second_tlv_code:
                process 'val';
                break;
            ..
            default
        }

    } ITERATE_TLV_END(start_ptr, type, length, tlv_ptr, tlv_size)



    Insertion in TLV
   -------------------
	byte *buff  = tlv_buffer_insert_tlv(byte *tlv_buff, uint8_t tlv_no,
                     uint8_t data_len, byte *data);

	byte *
	tlv_buffer_insert_tlv(byte  *buff, --> end pointer of the tlv
									  uint8_t tlv_no, --> what no of tlv [type]
									  uint8_t data_len, --> length of the data
									  byte  *data){ --> value of the data


		*buff = tlv_no; // tlv nos becomes the new end of the new tlv overhead
		*(buff+1) = data_len; // after the end the data len is inserted there in the tlv overhead
		memcpy(buff + TLV_OVERHEAD_SIZE, data, data_len); // fill the tlv
		return buff + TLV_OVERHEAD_SIZE + data_len; // returns a ptr to the to the end of the tlv that is
													// inserted in the buffer
	}

  Searching in TLV
 -------------------

	byte *
	tlv_buffer_insert_tlv(byte *tlv_buff, uint8_t tlv_no,
						 uint8_t data_len, byte *data);

	byte  *
	tlv_buffer_get_particular_tlv(byte  *tlv_buff, /*Input TLV Buffer this is the start of the tlv buffer */
						  uint32_t tlv_buff_size,               /*Input TLV Buffer Total Size */
						  uint8_t tlv_no,                            /*Input TLV Number i:e the types */
						  uint8_t *tlv_data_len){              /*Output TLV Data len */

		byte tlv_type, tlv_len, *tlv_value = NULL;

		ITERATE_TLV_BEGIN(tlv_buff, tlv_type, tlv_len, tlv_value, tlv_buff_size){

			if(tlv_type != tlv_no) continue;
			*tlv_data_len = tlv_len;
			return tlv_value;
		}ITERATE_TLV_END(tlv_buff, tlv_type, tlv_len, tlv_value, tlv_buff_size);

		*tlv_data_len = 0;

		return NULL;
	}

Hello Packet Format
--------------------

Ethernet Header --> ISIS_packet_header --> ISIS_TLV_SECTION --> FCS

No need for FCS [no checksum is implemented ]

APIS for creating hello packets
-------------------------------

TLV_OVERHEAD_SIZE  2 --> length of the TLV overhead i:e type+length

NODE_NAME_SIZE   16 --> Name of the Node

ETH_HDR_SIZE_EXCL_PAYLOAD --> size of the ethernet header excluding the payload

tcp_ip_get_new_pkt_buffer ( ) --> allocate a new packet to the buffer and returns a pointer at the end of the buffer on the right after the newly inserted packet

tcp_ip_free_pkt_buffer --> remove a packet by taking a pointer to the packet and the size of the packet

layer2_fill_with_broadcast_mac --> takes the mac address in the form a array and fills it up with arbitary value

GET_ETHERNET_HDR_PAYLOAD --> takes a pointer to the start of the ethernet header and returns the ethernet
payload

tcp_ip_covert_ip_p_to_n --> converts a ip address to binary formats

tcp_ip_covert_ip_n_to_p --> converts the ip address to the normal string formats

tlv_buffer_insert_tlv --> inserts a new data in the tlv

SET_COMMON_ETH_FCS --> takes the start of the ethernet header and the payload size of the ethernet and sets the FCS as 0 as we dont need to implement the checksums


Packet Capturing and logging Architecture
-------------------------------------------

The architecture should be proposed to work in such a way that the tcp ip stack should be able to capture the packet before the physical layer, which means that even before the
packets are reaching the destined destination the tcp ip stack should log the packets in the log files.


    Objectives implemented
    -----------------------
    1. Printing the packets that are ingressing and eggressing out of the interface
    2. Logging it just above the physical layer
    3. Parsing the tlv and the headers of the isis hello packets
    4. Printing the contents of the isis hello packets

    Architecture in details
    ------------------------

    For printing the packet contents we can use the API that has been implemented for tracing the packets
     >  nfc_register_for_packet_tracing(ISIS_ETH_PKT_TYPE, isis_print_pkt), where the isis_print_pkt is of type :
        a. typedef void(*nfc_cb)(void *, size_t);

    nfc_register_for_packet_tracing(ISIS_ETH_PKT_TYPE, isis_print_pkt) ---> Its telling that if the isis packet is of type ISIS_ETH_PKT_TYPE then print the packet

    For packet logging we can use isis_print_hello_packet fn() to log the packets into the log files

Logging internal Traces
------------------------

Traces are very useful while logging events and debugging

Example
-------

func --> void isis_enable_protocol_on_interface(interface_t *intf);

Inside this func if we want to check if the protcol is enabled on the interface or not then we can just write this following part when the protocol is getting enabled

sprintf(tlb, "ISIS PROTOCOL IS ENABLED ON THE INTERFACE")
tcp_trace(intf->att_node, tlb);

Processing Hello Packets
--------------------------

Entry point of the packets
----------------------------

void isis_pkt_receive(void  *arg, size_t arg_size) ----> Classification of the packets that whether it is a hello packet or a lsp packet
-------> Then process the packet accordingly using these 2 apis
  > isis_process_hello_pkt(node_t * node, interface_t *intf, ethernet_hdr_t *hello_eth_hdr, size_t pkt_size)
  > isis_process_isp_pkt(node_t *node, interface_t *intf, ethernet_hdr_t *isp_eth_hdr, size_t pkt_size)

Validation checks
------------------

static void isis_process_hello_packet
 > reject if the proto is not enabled on the interface
 > reject if the pkt of the intf is not qualifies i:e no ip address has been assigned on the interface
 > reject if the destination mac addr is not the broadcast addr
 > reject if the isis_tlv_intf_ip not present in hello pkt
 > reject if the neighboring intf ip addr does not fall in same subnet as the receipent interface
 > accept the packet :
    > create or update the interface adjacency from hello packet tlv contents

Adjacency Object Creation
---------------------------

Proposed Algorithm
--------------------

> if isis_adjacency_t doesn't exists then create a new one in down state
> iterating over hello_tlv_buffer and copying all the 6 tlvs values from hello to adjacency members
> track if there is change in any attribute of existing adjacency in step 2 (bool nbr_attr_changed)
> keep track if adj is newly created (bool new_adj)

Adjacency Timers --> [expiry and delete timers]
-----------------

Architecture of the delete timer
--------------------------------
 > Init state -> It should start automatically when the adjacency object is in down state
 > duration -> The proposed duration should be 5 sec
 > Action performed -> Delete the adjacency object permanently
 > Cancelled -> It should get cancelled if the adjacency is moved out of the down state or if it is deleted by the action of an admin [proto disabled on a intf]
 > Refresh -> It should be never be repeated automatically

This timer's main purpose is to give the adjacency object 5 sec to survive after 5 sec its getting deleted permanentlY

Architecture of the expiry timer
---------------------------------
 > Init state -> It should be started when the adj is moved to init or up state
 > duration --> It should be proposed as per the holding time
 > Action --> It should move the adjacency state to down and start the delete timer
 > Cancelled --> It can be cancelled if its getting deleted by an admin
 > Refreshed --> It should only be refreshed if there is good hello packet

The purpose of this timer is to not let the adjacency object stay in the up state if there is no good packet arriving until the holding time

Both the timers cannnot run at the same time.

        Proposed APIs for the timers
        -----------------------------

        Delete timers
             > static void isis_adjancency_start_delete_timer(isis_adjacency_t *adjancency);
             > static void isis_adjancency_stop_delete_timer(isis_adjacency_t *adjancency);

        Expiry timers
             > static void isis_adjacency_start_expiry_timer(isis_adjacency_t *adjacency);
             > static void isis_adjacency_stop_expiry_timer(isis_adjacency_t *adjacency);
             > static void isis_adjacency_refresh_timer(isis_adjacency_t *adjacency);




